<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Relay Viewer</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/xterm@5.3.0/css/xterm.css"
    />
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 0;
        background: #111;
        color: #eee;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      header, footer {
        padding: 0.75rem 1rem;
        background: #181818;
        display: flex;
        gap: 0.75rem;
        align-items: center;
      }
      main {
        flex: 1;
        display: grid;
        grid-template-columns: 280px minmax(0, 1fr);
        gap: 0.5rem;
        padding: 0.5rem;
        min-height: 0;
      }
      #sessions {
        background: #1c1c1c;
        border-radius: 6px;
        padding: 0.5rem;
        overflow-y: auto;
      }
      #sessions button {
        width: 100%;
        margin-bottom: 0.4rem;
        padding: 0.4rem;
        background: #282828;
        border: 1px solid #333;
        border-radius: 4px;
        color: inherit;
        text-align: left;
        cursor: pointer;
      }
      #sessions button.active {
        background: #3a3a3a;
        border-color: #555;
      }
      #terminal {
        background: #000;
        border-radius: 6px;
        padding: 0.5rem;
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        min-height: 0;
        overflow: hidden;
      }

      #terminal .xterm {
        flex: 1;
        min-height: 0;
      }

      #terminal .xterm-viewport {
        height: 100% !important;
      }
      label {
        font-size: 0.85rem;
        display: flex;
        flex-direction: column;
        color: #ccc;
      }
      input {
        margin-top: 0.25rem;
        padding: 0.4rem;
        border-radius: 4px;
        border: 1px solid #333;
        background: #202020;
        color: #eee;
      }
      button.primary {
        padding: 0.5rem 1rem;
        border-radius: 4px;
        border: none;
        background: #3b82f6;
        color: #fff;
        cursor: pointer;
      }
      #status {
        font-size: 0.85rem;
        color: #aaa;
      }
    </style>
  </head>
  <body>
    <header>
      <label>
        API Key
        <input id="apiKey" type="text" placeholder="sk-..." />
      </label>
      <label>
        Relay Host
        <input id="relayHost" type="text" value="127.0.0.1" />
      </label>
      <label>
        Relay Port
        <input id="relayPort" type="number" value="8787" />
      </label>
      <button class="primary" id="loadSessions">Load Sessions</button>
      <span id="status"></span>
    </header>
    <main>
      <aside id="sessions"></aside>
      <section id="terminal"></section>
    </main>
    <footer>
      <span>Tip: Press Load Sessions, then choose a session.</span>
    </footer>

    <script src="https://unpkg.com/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <script>
      const FRAME_HEADER_SIZE = 5; // 1 byte type + 4 byte length
      const FRAME_TYPE_OUTPUT = 0;
      const FRAME_TYPE_INPUT = 1;

      const apiKeyInput = document.getElementById('apiKey');
      const hostInput = document.getElementById('relayHost');
      const portInput = document.getElementById('relayPort');
      const loadButton = document.getElementById('loadSessions');
      const sessionsList = document.getElementById('sessions');
      const terminalContainer = document.getElementById('terminal');
      const statusEl = document.getElementById('status');

      let term = null;
      let socket = null;
      let buffer = new Uint8Array();
      let termDisposables = [];
      let pendingResize = null;
      let suppressResizeNotification = 0;
      let fitAddon = null;
      let resizeObserver = null;

      function setStatus(message) {
        statusEl.textContent = message ?? '';
      }

      function resizeBuffer(extraLength) {
        if (buffer.length >= extraLength) return buffer;
        const newBuf = new Uint8Array(extraLength);
        newBuf.set(buffer);
        buffer = newBuf;
        return buffer;
      }

      function appendBuffer(chunk) {
        const newBuf = new Uint8Array(buffer.length + chunk.length);
        newBuf.set(buffer, 0);
        newBuf.set(chunk, buffer.length);
        buffer = newBuf;
      }

      function shiftBuffer(n) {
        buffer = buffer.slice(n);
      }

      const textDecoder = new TextDecoder('utf-8');

      function processFrames() {
        while (buffer.length >= FRAME_HEADER_SIZE) {
          const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
          const frameType = view.getUint8(0);
          const frameLen = view.getUint32(1);
          const totalLen = FRAME_HEADER_SIZE + frameLen;
          if (buffer.length < totalLen) return;

          const payload = buffer.slice(FRAME_HEADER_SIZE, totalLen);
          shiftBuffer(totalLen);

          if (frameType === FRAME_TYPE_OUTPUT) {
            if (term) {
              const text = textDecoder.decode(payload, { stream: true });
              if (text) {
                term.write(text);
              }
            }
          }
        }
      }

      function sendInput(data) {
        if (!socket || socket.readyState !== WebSocket.OPEN) return;
        const payload = { type: 'input', data };
        const size = getCurrentSize();
        if (size) {
          payload.cols = size.cols;
          payload.rows = size.rows;
        }
        socket.send(JSON.stringify(payload));
      }

      function sendResizeRequest(cols, rows) {
        if (!socket || socket.readyState !== WebSocket.OPEN) return;
        if (!Number.isFinite(cols) || !Number.isFinite(rows)) return;
        const safeCols = Math.max(1, Math.trunc(cols));
        const safeRows = Math.max(1, Math.trunc(rows));
        socket.send(
          JSON.stringify({ type: 'resize_request', cols: safeCols, rows: safeRows })
        );
      }

      function getCurrentSize() {
        if (!term) return null;
        const cols = Number(term.cols);
        const rows = Number(term.rows);
        if (!Number.isFinite(cols) || !Number.isFinite(rows)) {
          return null;
        }
        return { cols, rows };
      }

      function applyResize(cols, rows) {
        const normalizedCols = Number(cols);
        const normalizedRows = Number(rows);
        if (!Number.isFinite(normalizedCols) || !Number.isFinite(normalizedRows)) {
          return;
        }

        const safeCols = Math.max(1, Math.trunc(normalizedCols));
        const safeRows = Math.max(1, Math.trunc(normalizedRows));
        pendingResize = { cols: safeCols, rows: safeRows };

        if (!term) {
          return;
        }

        if (term.cols === safeCols && term.rows === safeRows) {
          return;
        }

        suppressResizeNotification++;
        try {
          term.resize(safeCols, safeRows);
        } finally {
          if (suppressResizeNotification > 0) {
            suppressResizeNotification--;
          }
        }
      }

      function disposeTerminal() {
        if (!term) return;
        if (resizeObserver) {
          try {
            resizeObserver.disconnect();
          } catch (_) {}
        }
        resizeObserver = null;
        if (fitAddon && typeof fitAddon.dispose === 'function') {
          try {
            fitAddon.dispose();
          } catch (_) {}
        }
        fitAddon = null;
        for (const disposable of termDisposables) {
          try {
            disposable.dispose();
          } catch (_) {}
        }
        termDisposables = [];
        term.dispose();
        term = null;
      }

      function setupTerminal() {
        disposeTerminal();

        term = new Terminal({
          fontFamily: '"Berkeley Mono", "Fira Code", monospace',
          convertEol: false,
          allowProposedApi: true,
          theme: {
            background: '#000000',
            foreground: '#dddddd'
          }
        });

        if (window.FitAddon) {
          fitAddon = new window.FitAddon.FitAddon();
          term.loadAddon(fitAddon);
        }

        const clearHandler = term.parser.registerCsiHandler({ final: 'J' }, (params) => {
          const code = params.length === 0 ? 0 : params[0];
          if (code === 2) {
            // Ink redraws use CSI 2J; clear scrollback first so we don't duplicate full frames.
            term.clear();
            term.scrollToTop();
            return false;
          }
          return false;
        });
        termDisposables.push(clearHandler);

        terminalContainer.innerHTML = '';
        term.open(terminalContainer);
        term.focus();

        const dataSubscription = term.onData(data => sendInput(data));
        termDisposables.push(dataSubscription);

        const applyFit = () => {
          if (!fitAddon) {
            return;
          }
          suppressResizeNotification++;
          try {
            fitAddon.fit();
          } finally {
            if (suppressResizeNotification > 0) {
              suppressResizeNotification--;
            }
          }
          const size = getCurrentSize();
          if (size) {
            pendingResize = size;
            sendResizeRequest(size.cols, size.rows);
          }
        };

        const resizeSubscription = term.onResize(({ cols, rows }) => {
          pendingResize = { cols, rows };
          if (suppressResizeNotification > 0) {
            return;
          }
          sendResizeRequest(cols, rows);
        });
        termDisposables.push(resizeSubscription);

        if (window.ResizeObserver) {
          resizeObserver = new ResizeObserver(() => {
            if (!term) return;
            applyFit();
          });
          resizeObserver.observe(terminalContainer);
        }

        if (pendingResize) {
          suppressResizeNotification++;
          try {
            term.resize(pendingResize.cols, pendingResize.rows);
          } finally {
            if (suppressResizeNotification > 0) {
              suppressResizeNotification--;
            }
          }
        }

        const size = getCurrentSize();
        if (size) {
          pendingResize = size;
        }

        applyFit();
      }

      async function loadSessionsList() {
        const key = apiKeyInput.value.trim();
        const host = hostInput.value.trim() || '127.0.0.1';
        const port = portInput.value.trim() || '8787';
        if (!key) {
          setStatus('API key required');
          return;
        }

        setStatus('Loading sessions...');
        try {
          const response = await fetch(`/sessions?key=${encodeURIComponent(key)}&host=${encodeURIComponent(host)}&port=${encodeURIComponent(port)}`);
          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || 'Failed to load sessions');
          }
          renderSessions(data.sessions || [], { key, host, port });
          setStatus(`Loaded ${data.sessions.length} session(s)`);
        } catch (error) {
          setStatus(error.message);
        }
      }

      function renderSessions(list, meta) {
        sessionsList.innerHTML = '';
        if (!list.length) {
          const p = document.createElement('p');
          p.textContent = 'No active sessions';
          sessionsList.appendChild(p);
          return;
        }

        list.forEach(session => {
          const btn = document.createElement('button');
          const dims = session.cols && session.rows ? ` (${session.cols}x${session.rows})` : '';
          const status = session.active ? ' (active)' : '';
          btn.textContent = `${session.id}${dims}${status}`;
          btn.addEventListener('click', () => connectSession(session.id, meta));
          sessionsList.appendChild(btn);
        });
      }

      function connectSession(sessionId, meta) {
        const { key, host, port } = meta;
        setupTerminal();
        if (socket) {
          socket.close();
        }
        buffer = new Uint8Array();
        const url = new URL(window.location.origin.replace(/^http/, 'ws'));
        url.pathname = '/ws';
        url.searchParams.set('sessionId', sessionId);
        url.searchParams.set('key', key);
        url.searchParams.set('host', host);
        url.searchParams.set('port', port);

        socket = new WebSocket(url.toString());
        socket.binaryType = 'arraybuffer';

        socket.onopen = () => {
          setStatus(`Connected to session ${sessionId}`);
          term.focus();
          const size = getCurrentSize();
          if (size) {
            sendResizeRequest(size.cols, size.rows);
          }
        };
        socket.onclose = ev => {
          const flush = textDecoder.decode();
          if (flush && term) {
            term.write(flush);
          }
          setStatus(`Connection closed (${ev.code})`);
        };
        socket.onerror = () => setStatus('WebSocket error');
        socket.onmessage = event => {
          const { data } = event;
          if (typeof data === 'string') {
            try {
              const parsed = JSON.parse(data);
              if (parsed.type === 'error') {
                setStatus(`Relay error: ${parsed.message}`);
              } else if (parsed.type === 'resize') {
                applyResize(parsed.cols, parsed.rows);
              }
            } catch (_) {
              // ignore non-JSON strings
            }
            return;
          }

          const handleArrayBuffer = (arrayBuffer) => {
            const chunk = new Uint8Array(arrayBuffer);
            appendBuffer(chunk);
            processFrames();
          };

          if (data instanceof ArrayBuffer) {
            handleArrayBuffer(data);
          } else if (data instanceof Blob) {
            data.arrayBuffer().then(handleArrayBuffer).catch(() => {
              setStatus('Failed to decode binary frame');
            });
          } else {
            // Fallback: try to coerce via TextEncoder/decoder
            try {
              const chunk = new TextEncoder().encode(String(data));
              appendBuffer(chunk);
              processFrames();
            } catch (_) {
              setStatus('Received unknown data format');
            }
          }
        };
      }

      loadButton.addEventListener('click', loadSessionsList);
    </script>
  </body>
</html>
